<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="main">
        <div class="container">
            <div class="header">
                <img src="https://github.com/The-GPT-Warriors/ASLFrontend/assets/107821010/a767e359-1bb9-4fda-86f6-3e870d85938e" alt="logo" class="logo">
                <h1 class="title">Welcome to The GPT Warriors Organization!!</h1>
            </div>
            <div class="main">
                <h3 class="description1">Team Members - Tay Kim, Anthony Bazhenov, Ethan Tran, Emaad Mir</h3>
                <br>
                <div class="camera-container" style="position: relative; display: inline-block;">
                    <div class="camera"></div>
                    <canvas id="overlayCanvas" style="position: absolute; top: 0; left: 0; pointer-events: none;"></canvas>
                </div>
                <br>
                <input class="text" id="predictionInput" placeholder="Predictions from the model will go here" readonly>
                <div id="timer" style="color: black; margin-top: 10px;">Next capture in: 2 seconds</div>
                <br>
                <br>
                <p class="description2">To get started, please log in or make an account.</p>
                <br>
                <button class="button1" onclick="window.location.href='login.html'">Login</button>
                <button class="button2" onclick="window.location.href='signup.html'">Create an Account</button>
        </div>
    </div>
  <script>
    const video = document.createElement('video');
    video.setAttribute('autoplay', '');
    video.setAttribute('playsinline', '');
    video.setAttribute('muted', '');
    video.style.width = '600px';
    video.style.height = '450px';
    video.style.display = 'block';
    video.style.objectFit = 'cover';
    
    const canvas = document.createElement('canvas');
    const overlayCanvas = document.getElementById('overlayCanvas');
    const cameraDiv = document.querySelector('.camera');
    const cameraContainer = document.querySelector('.camera-container');
    const timerElement = document.getElementById('timer');
    const predictionInput = document.getElementById('predictionInput');
    
    // Set initial canvas size
    overlayCanvas.style.width = '600px';
    overlayCanvas.style.height = '450px';
    
    const constraints = {
      video: {
        width: { ideal: 640 },
        height: { ideal: 480 }
      }
    };
    
    // Add video to DOM first
    cameraDiv.appendChild(video);
    
    navigator.mediaDevices.getUserMedia(constraints)
      .then((stream) => {
        video.srcObject = stream;
        video.onloadedmetadata = () => {
          video.play();
          
          // Wait a bit for video to actually start playing
          setTimeout(() => {
            // Set overlay canvas dimensions to match video
            const videoWidth = video.videoWidth || 600;
            const videoHeight = video.videoHeight || 450;
            
            overlayCanvas.width = videoWidth;
            overlayCanvas.height = videoHeight;
            
            // Draw green bounding box
            drawBoundingBox();
          }, 100);
        };
      })
      .catch((err) => {
        console.error('Error accessing camera:', err);
        cameraDiv.innerHTML = '<p style="color: red; padding: 20px;">Error accessing camera. Please allow camera permissions and refresh the page.</p>';
      });
    
    function drawBoundingBox() {
      if (!overlayCanvas) return;
      
      const ctx = overlayCanvas.getContext('2d');
      ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
      
      // Draw a centered green bounding box (adjust size as needed)
      // Scale the box to be about 60% of the video width
      const boxWidth = overlayCanvas.width * 0.6;
      const boxHeight = overlayCanvas.height * 0.6;
      const x = (overlayCanvas.width - boxWidth) / 2;
      const y = (overlayCanvas.height - boxHeight) / 2;
      
      ctx.strokeStyle = '#00ff00'; // Green color
      ctx.lineWidth = 4;
      ctx.strokeRect(x, y, boxWidth, boxHeight);
    }
    
    function captureAndSendImage() {
      if (!video.videoWidth || !video.videoHeight) return;
      
      // Set canvas dimensions to match video
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      
      // Draw the current frame from the video onto the canvas
      const ctx = canvas.getContext('2d');
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      
      // Get base64 representation of the image data
      const imageData = canvas.toDataURL('image/png').replace(/^data:image\/\w+;base64,/, '');
      
      // Send the image data to the backend
      fetch('http://localhost:8085/image', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ image: imageData }),
      })
      .then(response => response.json())
      .then(data => {
        console.log('Response:', data);
        // Display the prediction in the input field
        if (data.prediction) {
          predictionInput.value = 'Prediction: ' + data.prediction;
        } else if (data.letter) {
          predictionInput.value = 'Prediction: ' + data.letter;
        } else if (data.message) {
          predictionInput.value = data.message;
        }
      })
      .catch(error => {
        console.error('Error:', error);
        predictionInput.value = 'Error: Could not connect to backend. Make sure the backend is running on port 8085.';
      });
    }
    
    // Capture an image every 2 seconds
    setInterval(function() {
      captureAndSendImage();
      updateTimer();
    }, 2000);
    
    function updateTimer() {
      let seconds = 2;
      if (timerElement) {
        timerElement.textContent = `Next capture in: ${seconds} seconds`;
        const countdown = setInterval(() => {
          seconds--;
          if (timerElement) {
            timerElement.textContent = `Next capture in: ${seconds} seconds`;
          }
          if (seconds <= 0) {
            clearInterval(countdown);
          }
        }, 1000);
      }
    }
  </script>
</body>
</html>
